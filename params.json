{"name":"Paladin","tagline":"Javascript composition and delegation library","body":"Paladin\r\n=======\r\n\r\nJavascript Object Composition library, combine constructors and create objects as needed.\r\nLeverage Javascript's own unique feature - `prototype` - but also forget about ever typing it again!\r\n\r\n# Favour composition over inheritance\r\n\r\nWith Paladin you can put together all your pieces into objects which you can create on-the-fly.\r\n\r\nYou can re-use your components and combine them together, cache them into functions if you intend to\r\ncreate multiple objects of the same type, or just create it on the fly, leveraging javascript's higher-order\r\nfunctions.\r\n\r\nSay you have a `Car`. All Cars have an `Engine`, but not all Cars have a `CDPlayer`.\r\n\r\nWith Paladin you can simply do:\r\n\r\n`var simpleCar = Paladin.compose([Car, Engine]);`\r\n\r\nthen pass some states when you instantiate the car:\r\n\r\n`var toyota = simpleCar({ model: 'Toyota' });`\r\n\r\nAs `Paladin.compose` is returning a function you can even create a simpleCar by doing:\r\n\r\n`var ford = Paladin.compose([Car, Engine])({ model: 'Ford'});`\r\n\r\n`ford` is a Car, and the Engine methods have a common context!\r\n\r\nNaturally an Engine can be mounted on a `Plane` for example...\r\n\r\n`var boeing = Paladin.compose([Plane, Engine])({ model: '777' });`\r\n\r\nNow let's create a car with a CDPlayer, let's start it and rock our playlist:\r\n\r\n```javascript\r\nvar c = Paladin.compose([Car, Engine, CDPlayer])({ model: 'Ferrari Paladin' });\r\nc.start()\r\n  .addTrack('Cirith Ungol - Atom Smasher')\r\n  .addTrack('Manilla Road - Astronomica')\r\n  .addTrack('Warlord - Black Mass')\r\n  .addTrack('Salem\\'s Wych - Betrayer of Kings')\r\n  .play()\r\n  .next()\r\n  .next()\r\n  .next()\r\n  .pause();\r\n```\r\n\r\n## States, init and modules\r\n\r\nThe copmosed function takes three optional parameters, states, init and modules.\r\nThe states object sets public members to the passed values. I.e. `{ name: 'joe' }` sets the public member name to joe.\r\nWith this you can attach functions as methods (see example below).\r\nInit takes method names and arrays for parameters. I.e. `{ setName: ['joe'] }` calls the method `setName` and passes the parameter `'joe'`.\r\n\r\n### States\r\n\r\nOnce you generated a composited function, you can create your objects by passing a states object, but you can also call the states method\r\nsubsequently to the object creation. I.e.\r\n```javascript\r\nvar simpleCar = Paladin.compose([Car, Engine]);\r\nvar myCar = new simpleCar();\r\nmyCar.states({ model: 'My Car'});\r\n```\r\nYou can also attach methods with states:\r\n\r\n```javascript\r\nfunction Break() {\r\n  console.log('Eeeeeeeeeeekkkkk!');\r\n}\r\n\r\nvar myBreakingCar = new simpleCar({ skid: Break });\r\nmyBreakingCar.skid(); // eeeeeeeeeeeeeeeeeeekkkk!\r\n```\r\n\r\n### Init\r\n\r\nSimilarly to states, you can pass an object as the second argument which will call methods on the newly created object. The object structure is \r\n`{ methodName: [ArrayOfArguments] }`.\r\n\r\nFor example:\r\n```javascript\r\nmyCar.init({ start: [], setModel: ['Ferrari Paladin']});\r\n```\r\n\r\n### Modules\r\n\r\nModules is interesting in two respects:\r\n\r\n* it allows functions adopting the Module pattern to be attached to another function\r\n* it namespaces the methods to avoid method collision/override\r\n\r\nSo let's take a look at an example to understand:\r\n\r\n```javascript\r\nfunction CarTank() {\r\n  var capacity = 50,\r\n    current = 0;\r\n  return {\r\n    fill: function() {\r\n      current = 50; // tank is filled with fuel\r\n    },\r\n    consume: function() {\r\n      capacity -= 1;\r\n      if (current === 0) {\r\n        console.log('We\\'re out of fuel!');\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction OilTank() {\r\n  var capacity = 10,\r\n    current = 0;\r\n  return {\r\n    fill: function() {\r\n      current = 10; // oil tank is filled with fuel\r\n    },\r\n    consume: function() {\r\n      capacity -= 1;\r\n    }\r\n  };\r\n}\r\n```\r\nBoth modules have a fill method so we may have run into problems...\r\nUsing the modules method the `fill()` method gets namespaced.\r\n\r\n```javascript\r\nmyCar.modules([CarTank, OilTank]);\r\n// let's refill oil and fuel\r\nmyCar.OilTank.fill();\r\nmyCar.CarTank.fill();\r\n```\r\n\r\n## Composing the Composite\r\n\r\nAs the result of a composition is a function, you can reuse that to further re-compose it.\r\n```javascript\r\nvar simpleCar = Paladin.compose([Car, Engine]);\r\nvar coolCar = Paladin.compose([simeplCar, CDPlayer]);\r\nvar DeLoreanTimeMachine = Paladin.compose([coolCar, TimeMachine]);\r\n```\r\n\r\n## Complete Example\r\n\r\nAnd finally a more complete example. A javascript summary of Moorcock's Stormbringer Saga... ***spoiler alert***\r\n\r\n```javascript\r\n/**\r\n * A javascript version of Moorcock's Stormbringer Saga\r\n */\r\n\r\nfunction Character () {\r\n  this.name = '';\r\n}\r\n\r\nfunction Sorcerer () {\r\n  this.cast = function(spell) {\r\n    console.log(this.name + ' is casting ' + spell);\r\n    return this;\r\n  };\r\n}\r\n\r\nfunction Warrior () {\r\n  var weapon = '';\r\n  this.setWeapon = function (weaponObject) {\r\n    weapon = weaponObject;\r\n    return this;\r\n  };\r\n  this.getWeapon = function() {\r\n    return weapon;\r\n  };\r\n}\r\n\r\n// module pattern function\r\nfunction skills() {\r\n  var skills = [],\r\n    skillsModule;\r\n  skillsModule = {\r\n    addSkill: function(name) {\r\n      skills.push(name);\r\n      return skillsModule.addSkill;\r\n    },\r\n    getSkills: function() {\r\n      return skills;\r\n    }\r\n  };\r\n  return skillsModule;\r\n}\r\n\r\nfunction Sword() {\r\n  var name = '';\r\n  this.setName = function(weaponName) {\r\n    name = weaponName;\r\n  };\r\n  this.getName = function() {\r\n    return name;\r\n  };\r\n}\r\n\r\nfunction Demon() {\r\n  this.suckLife = function() {\r\n    console.log('I\\'m sucking life out of my victim');\r\n  }\r\n}\r\n\r\nfunction battleCast() {\r\n  console.log(this.name + ' is casting spells while wielding ' + this.getWeapon().getName() );\r\n  return this;\r\n}\r\n\r\nfunction destroyWorld() {\r\n  console.log('Blowing the Horn of Fate and destroying the world right now....');\r\n}\r\n\r\n// create a sword that's also a demon\r\nvar DemonSword = Paladin.compose([Sword, Demon]),\r\n  // Stormbringer is the coolest sword in the universe\r\n  Stormbringer = new DemonSword({}, { setName : ['Stormbringer']}),\r\n  // MournBlade is Stormbringer's twin blade\r\n  MournBlade = new DemonSword({}, { setName : ['MournBlade']});\r\n\r\n// create the race of Melnibone'\r\nvar Melnibonean = Paladin.compose([Character, Sorcerer, Warrior]),\r\n  // create Elric, the anithero and attach the battleCast method alised as fight\r\n  Elric = new Melnibonean({name: 'Elric', fight: battleCast, destroy: destroyWorld },\r\n    // set Elric's weapon to Stormbringer\r\n    { setWeapon: [Stormbringer] },\r\n    // add the skills module (namespaced to skills)\r\n    [ skills ]),\r\n  // Yrkoon is Elric's evil cousin who happens to wield MournBlade\r\n  Yrkoon = new Melnibonean({name: 'Yrkoon'}, { setWeapon: [MournBlade] });\r\n\r\n// let's test everything works as supposed\r\nElric.fight();\r\n// this is interesting because addSkill() returns addSkill so you can chain brackets\r\n// until - of course - Elric destroys the world...\r\nElric.skills.addSkill('Summon Arioch')('Be and Albino Prince')('Destroy World');\r\n// and let's print it out\r\nconsole.log('Elric has the following skills: ' + Elric.skills.getSkills().join(', '));\r\nElric.destroy();\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}